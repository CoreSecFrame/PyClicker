using System;
using System.Management;
using System.Security.Cryptography;
using System.Text;

namespace PyClickerRecorder
{
    public static class LicenseManager
    {
        // IMPORTANT: This public key MUST be replaced with the one generated by the KeyGenerator tool.
        private const string PublicKeyBase64 = "MIIBCgKCAQEAutqh6XTIFfNqxFMkUy2TeQLaYdUEU4CPJLo0Bf13oLs++3+s266VbNtwcFkcgX5ap0F+q2rf+auHcw6XvctDENznNazWKHkfoQRpAPytmPVskiTPYzzhil9WfFXdRMbtBRSRPxbwV/0m/35LMdR5mt0136K8g+jx3jtBimQfR2UMbP2JbyNw3jtMrhsKfZDHuwLKASQWIMU0qGPvCsoVWu/WeYWbjsGusfRo4atMKGi5y6jRcOFBbAZ+bHJ1dfHOJuYHYv5ieEPIE0QyjTX93aVF1MFd1hPfW//6p0Pk+HfyAIiYmz6sGSyMumFaN8dzPZyscyduvDs8dZKzN4NBnwIDAQAB";

        private static string GetRawMachineId()
        {
            try
            {
                var mbs = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BaseBoard");
                ManagementObjectCollection mbsList = mbs.Get();
                string id = "";
                foreach (ManagementObject mo in mbsList)
                {
                    id = mo["SerialNumber"]?.ToString() ?? "";
                    if (!string.IsNullOrEmpty(id))
                    {
                        break;
                    }
                }
                return string.IsNullOrEmpty(id) ? "DefaultMachineId" : id;
            }
            catch (Exception)
            {
                return "CouldNotRetrieveMachineId";
            }
        }

        public static string GetEncryptedMachineId()
        {
            try
            {
                string machineId = GetRawMachineId();
                using (var rsa = RSA.Create())
                {
                    byte[] publicKeyBytes = Convert.FromBase64String(PublicKeyBase64);
                    rsa.ImportRSAPublicKey(publicKeyBytes, out _);
                    
                    byte[] machineIdBytes = Encoding.UTF8.GetBytes(machineId);
                    byte[] encryptedBytes = rsa.Encrypt(machineIdBytes, RSAEncryptionPadding.OaepSHA256);
                    
                    return Convert.ToBase64String(encryptedBytes);
                }
            }
            catch (Exception ex)
            {
                // Return a clear error message if something goes wrong, e.g., invalid public key
                return $"Error generating ID: {ex.Message}";
            }
        }

        public static bool IsLicenseValid(string licenseKey)
        {
            if (string.IsNullOrWhiteSpace(licenseKey))
            {
                return false;
            }

            try
            {
                string machineId = GetRawMachineId();
                byte[] machineIdBytes = Encoding.UTF8.GetBytes(machineId);
                byte[] signatureBytes = Convert.FromBase64String(licenseKey);

                using (var rsa = RSA.Create())
                {
                    byte[] publicKeyBytes = Convert.FromBase64String(PublicKeyBase64);
                    rsa.ImportRSAPublicKey(publicKeyBytes, out _);

                    return rsa.VerifyData(machineIdBytes, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
                }
            }
            catch
            {
                // Catches errors from invalid Base64 string, cryptographic issues, etc.
                return false;
            }
        }
    }
}
